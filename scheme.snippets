#!/usr/bin/env ruby

# Definitions
snippet header beginner
	#reader(lib "htdp-beginner-reader.ss" "lang")((modname |2|) (read-case-sensitive #t) (teachpacks ((lib "image.ss" "teachpack" "2htdp") (lib "universe.ss" "teachpack" "2htdp"))) (htdp-settings #(#t constructor repeating-decimal #f #t none #f ((lib "image.ss" "teachpack" "2htdp") (lib "universe.ss" "teachpack" "2htdp")))))
snippet header intermediate
	#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname |1|) (read-case-sensitive #t) (teachpacks ((lib "image.ss" "teachpack" "2htdp") (lib "universe.ss" "teachpack" "2htdp"))) (htdp-settings #(#t constructor repeating-decimal #f #t none #f ((lib "image.ss" "teachpack" "2htdp") (lib "universe.ss" "teachpack" "2htdp")))))
snippet header advanced
	#reader(lib "htdp-advanced-reader.ss" "lang")((modname |1|) (read-case-sensitive #t) (teachpacks ((lib "image.ss" "teachpack" "2htdp") (lib "universe.ss" "teachpack" "2htdp"))) (htdp-settings #(#t constructor repeating-decimal #t #t none #f ((lib "image.ss" "teachpack" "2htdp") (lib "universe.ss" "teachpack" "2htdp")))))

snippet defun
	(defun ${1:name} (${2:args})
		${3:code})

snippet fun
	;; ${1:function-name} : ${2:arg-list} -> ${3:return-type}
	;; ${4:purpose statement here}
	;; Example:
	;; ($1 ${5:...}) = ${6:Example here}
	;; Strategy: ${7:structural decomposition on}
	(define ($1 ${8:ARG LIST HERE})
	  (${9:FUNCTION CODE HERE}))
	;; Tests-begin
	(define-test-suite $1-test
	  (check-equal? ($1 $5) $6 "${10:MSG}"))
	(run-tests $1-test)
	;; Tests-end

snippet helper
	;; ${1:function-name} : ${2:arg-list} -> ${3:return-type}
	;; ${4:purpose statement here}
	;; Example:
	;; ($1 ${5:...}) = ${6:Example here}
	;; Strategy: ${7:structural decomposition on}
	(define ($1 ${8:ARG LIST HERE})
	  (${9:FUNCTION CODE HERE}))
	;; Tests written in test suite at the bottom.

snippet test
	;; Tests-begin
	(define-test-suite ${1:xx}-test
	  (check-equal? ($1 ${2:...}) ${3:result} "${4:MSG}")
	  (check-equal? ($1 $2) $3 "$4")
	  (check-equal? ($1 $2) $3 "$4"))
	(run-tests $1-test)
	;; Tests-end

snippet main 
	;; start with ($1 0)
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	;; MAIN FUNCTION.
	;; start the simulation with the rectangle in middle of scence.
	;; run : Any -> World
	;; Ignores its argument and runs the world. 
	;; Returns the final state of the world.
	;; strategy: Function Composition
	(define (${1:run} ${2:any})
	  (big-bang ${3:(initial-world 0)}
				(on-mouse ${4:world-after-mouse-event})
				(on-key ${5:world-after-key-event})
				(on-tick ${6:world-after-tick-event})
				(to-draw ${7:render})))
	${8}

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

snippet rackunit
	(require rackunit)
	(require rackunit/text-ui)
	(require "extras.rkt")

snippet pro
	(provide ${1:run})${2}

snippet datadef Compound Information (Structured values)
	(define-struct ${1:stuct-name} (${2:arg1} ${3:arg2} ${4:arg3}))
	;; A $1 is a (make-$1 ${5:Number})
	;; Interpretation: 
	;; ${6:Interpretation Here}
	;; Template:
	;; $1-fn : $1-> ??
	;; (define ($1-fn ${7:w})
	;;    (($1-$2 $7)
	;;   	($1-$3 $7)
	;;		($1-$4 $7)...))

snippet datadef Itemization Information
	;; A ${1:XXX} is a ${2:YYY} that is one of:
	;; -- "${3:One}"   (interp: )
	;; -- "${4:Two}"          (interp:)
	;; -- "${5:any other}"     (interp:)
	;; -- any other event (interp: ignored)

	;;(define (${6:mev}-fn $6)
	;;  (cond
	;;    [(${7:XXX}=? $6 "$3") ...]
	;;    [($7=? $6 "$4") ...]
	;;    [($7=? $6 "$5") ...]
	;;    [else ...]))

snippet datadef Partition Data
	;; A ${1:TaxableIncome} is a ${2:positive Number},
	;; which is one of:
	;; ${3:[0-10000)}
	;; ${4:[10000,20000)}
	;; ${5} 
	;;(define (tax-on amt)
	;;(cond
	;;[(and (<= 0 amt) (< amt 10000)) ...]
	;;[(and (<= 10000 amt) (< amt 20000)) ...]
	;;[(<= 20000 amt) ...]))

snippet datadef List (Self-References)
	;; A ListOf${1:Something} (LO${2:X}) is either
	;; -- empty
	;; -- (cons $1 LO$2)

	;; lo${3:x}-fn : LO$2 -> ??
	;; (define (lo$3-fn lob)
	;;   (cond
	;;     [(empty? lob) ...]
	;;     [else (...
	;;             (first lo$3)
	;;             (lo$3-fn (rest lob)))]))

snippet strat Structural Decomposition 
	;; Strategy: Structural Decomposition on ${1:Something} : ${2}

snippet strat Domain Knowledge 
	;; Strategy: Domain Knowledge

snippet strat Function Composition 
	;; Strategy: Function Composition 

snippet strat Higher Order Function Composition 
	;; Strategy: Higher Order Function Composition 

snippet strat Structural Decomposition with Accumulator
	;; Strategy: Structural Decomposition on ${1:Something} : ${2} + Accumulator [${3:a}]

snippet let
	(let ((${1:name} ${2:declaration}))
		${3:body})

snippet flet
	(flet ((${1:name} (${2:args}) ${3:body}))
		${4:body})
	
snippet defparamameter
	(defparameter ${1:name} ${2:declaration})

snippet defvar
	(defvar ${1:name} ${2:declaration})

# Conditionals

snippet if
	(if ${1:conditional} ${2:true} ${3:false})

snippet foldr
	(foldr 
	   ; ${1:Book ListOf<Book>} -> ${2:Number}
	   ; ${3:returns XXX}
	   ; ${4:Strategy: structural decomposition on b : Book}
	   (lambda(${5:n lon})
		 (${6:(xxx n) num}))
	   ${7:0} ${8:inventory})

snippet when
	(when ${1:conditional} ${2:true})

snippet unless
	(unless ${1:conditional} ${2:false})

snippet case
	(case ${1:target}
		((${2:possibility}) ${3:body})
		(otherwise ${4:else}))

snippet lambda
	; ${1:Book ListOf<Book>} -> ${2:Number}
	; ${3:returns XXX}
	; ${4:Strategy: structural decomposition on b : Book}
	(lambda (${5:args})
	(${6:body}))
